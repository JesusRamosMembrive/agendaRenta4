# Estrategia de Automatizaci√≥n

**Fecha de creaci√≥n**: 2025-10-28
**Estado**: Planificaci√≥n futura (Stage 2/3)
**Versi√≥n**: 1.0

---

## üéØ Prop√≥sito de este Documento

Este documento analiza **qu√© tareas del control de calidad web se pueden automatizar** y propone una estrategia h√≠brida (humano + m√°quina) para implementar en etapas futuras.

**Contexto**: Tu esposa revisa manualmente 8 aspectos del sitio web del banco:
1. Enlaces rotos
2. Enlaces incorrectos
3. Textos - erratas
4. Informaci√≥n actualizada
5. Preguntas frecuentes
6. CTAs (Call-to-Actions)
7. Im√°genes
8. Dise√±o

**Pregunta**: ¬øCu√°les de estos se pueden automatizar?

---

## ü§ñ An√°lisis de Automatizaci√≥n

### Tareas F√°cilmente Automatizables ‚úÖ

#### 1. Enlaces Rotos
**Qu√© detecta**: Links que devuelven error 404, 500, timeout, etc.

**Tecnolog√≠a**:
```python
import requests
from bs4 import BeautifulSoup

def check_broken_links(url):
    page = requests.get(url)
    soup = BeautifulSoup(page.content, 'html.parser')

    broken_links = []
    for link in soup.find_all('a', href=True):
        href = link['href']
        try:
            response = requests.get(href, timeout=5)
            if response.status_code >= 400:
                broken_links.append({
                    'url': href,
                    'status': response.status_code,
                    'text': link.text
                })
        except Exception as e:
            broken_links.append({
                'url': href,
                'error': str(e)
            })

    return broken_links
```

**Precisi√≥n**: ~95%
**Falsos positivos**: Rate limiting, firewall blocks, links que requieren auth
**Esfuerzo**: 1 d√≠a implementaci√≥n
**Valor**: ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê (muy alto - encuentra problemas objetivos)

---

#### 2. Enlaces Incorrectos
**Qu√© detecta**:
- Links internos que apuntan a dominio externo
- Redirects sospechosos
- Links a p√°ginas descontinuadas

**Tecnolog√≠a**:
```python
def check_incorrect_links(url, valid_domains=['renta4.com']):
    page = requests.get(url)
    soup = BeautifulSoup(page.content, 'html.parser')

    suspicious_links = []
    for link in soup.find_all('a', href=True):
        href = link['href']
        parsed = urlparse(href)

        # Check if internal link goes to external domain
        if is_internal_looking(link.text) and parsed.netloc not in valid_domains:
            suspicious_links.append({
                'url': href,
                'reason': 'Internal link to external domain',
                'text': link.text
            })

        # Check for redirects
        response = requests.get(href, allow_redirects=False)
        if response.is_redirect:
            suspicious_links.append({
                'url': href,
                'redirects_to': response.headers['Location'],
                'reason': 'Unexpected redirect'
            })

    return suspicious_links
```

**Precisi√≥n**: ~80%
**Falsos positivos**: Links leg√≠timos a partners, CDNs
**Esfuerzo**: 1-2 d√≠as implementaci√≥n
**Valor**: ‚≠ê‚≠ê‚≠ê‚≠ê (alto - pero requiere configuraci√≥n de reglas)

---

#### 3. Im√°genes Rotas
**Qu√© detecta**:
- Im√°genes que no cargan (404)
- Im√°genes sin alt text
- Im√°genes muy pesadas (>2MB)

**Tecnolog√≠a**:
```python
def check_images(url):
    page = requests.get(url)
    soup = BeautifulSoup(page.content, 'html.parser')

    image_issues = []
    for img in soup.find_all('img'):
        src = img.get('src')
        alt = img.get('alt')

        # Check if image loads
        try:
            response = requests.get(src, timeout=5)
            if response.status_code != 200:
                image_issues.append({
                    'src': src,
                    'issue': f'HTTP {response.status_code}'
                })

            # Check size
            size_mb = len(response.content) / (1024 * 1024)
            if size_mb > 2:
                image_issues.append({
                    'src': src,
                    'issue': f'Large file ({size_mb:.2f}MB)'
                })
        except Exception as e:
            image_issues.append({
                'src': src,
                'issue': f'Failed to load: {e}'
            })

        # Check alt text
        if not alt:
            image_issues.append({
                'src': src,
                'issue': 'Missing alt text (accessibility)'
            })

    return image_issues
```

**Precisi√≥n**: ~90%
**Falsos positivos**: Lazy-loaded images, images behind auth
**Esfuerzo**: 1 d√≠a implementaci√≥n
**Valor**: ‚≠ê‚≠ê‚≠ê‚≠ê (alto - accesibilidad + UX)

---

#### 4. Textos - Erratas (Parcialmente)
**Qu√© detecta**:
- Palabras mal escritas
- Errores ortogr√°ficos obvios
- Problemas gramaticales b√°sicos

**Tecnolog√≠a**:
```python
import language_tool_python

def check_spelling(url):
    page = requests.get(url)
    soup = BeautifulSoup(page.content, 'html.parser')

    # Extract text content
    text = soup.get_text()

    # Check with LanguageTool
    tool = language_tool_python.LanguageTool('es')
    matches = tool.check(text)

    errors = []
    for match in matches:
        errors.append({
            'text': match.context,
            'suggestion': match.replacements[:3],
            'message': match.message,
            'offset': match.offset
        })

    return errors
```

**Precisi√≥n**: ~70%
**Falsos positivos**: Muchos t√©rminos t√©cnicos/financieros no reconocidos
**Esfuerzo**: 1 d√≠a implementaci√≥n + configurar diccionario custom
**Valor**: ‚≠ê‚≠ê‚≠ê (medio - muchos falsos positivos, humano debe validar)

**Limitaciones**:
- No entiende contexto financiero
- Requiere diccionario custom de t√©rminos bancarios
- No detecta errores sem√°nticos (palabra correcta, contexto incorrecto)

---

### Tareas Dif√≠cilmente Automatizables ‚ö†Ô∏è

#### 5. Informaci√≥n Actualizada
**Qu√© requiere**: Verificar que datos (tasas, fechas, promociones) est√°n al d√≠a

**Por qu√© es dif√≠cil**:
- Requiere fuente de verdad (¬øcu√°l es la tasa correcta?)
- Sin API del banco, no hay forma de validar autom√°ticamente
- Requiere juicio humano: "¬øEsta promoci√≥n ya expir√≥?"

**Posible automatizaci√≥n parcial**:
```python
# Detectar fechas pasadas en textos
def check_outdated_dates(url):
    page = requests.get(url)
    soup = BeautifulSoup(page.content, 'html.parser')
    text = soup.get_text()

    # Find dates in text
    dates = extract_dates(text)  # regex or NLP
    today = datetime.now()

    old_dates = []
    for date in dates:
        if date < today - timedelta(days=180):  # 6 months old
            old_dates.append({
                'date': date,
                'context': get_surrounding_text(date, text)
            })

    return old_dates
```

**Precisi√≥n**: ~50% (muchos falsos positivos)
**Esfuerzo**: 2-3 d√≠as + alto mantenimiento
**Valor**: ‚≠ê‚≠ê (bajo - humano tiene que validar casi todo)

**Recomendaci√≥n**: Dejar 100% manual, no vale la pena automatizar.

---

#### 6. Preguntas Frecuentes (FAQs)
**Qu√© requiere**: Evaluar si FAQs son relevantes, actuales, y responden lo que usuarios preguntan

**Por qu√© es dif√≠cil**:
- Completamente subjetivo
- Requiere an√°lisis de queries de usuarios (analytics)
- Requiere juicio sobre relevancia

**Posible automatizaci√≥n parcial**:
- Comparar con analytics: ¬øestas FAQs coinciden con b√∫squedas reales?
- Requiere acceso a Google Analytics o sistema de b√∫squeda interno

**Precisi√≥n**: N/A (demasiado subjetivo)
**Esfuerzo**: 3-5 d√≠as + integraci√≥n con analytics
**Valor**: ‚≠ê (muy bajo - ROI negativo)

**Recomendaci√≥n**: Dejar 100% manual.

---

#### 7. CTAs (Call-to-Actions)
**Qu√© requiere**: Verificar que botones/links de acci√≥n funcionan y son efectivos

**Automatizable** ‚úÖ:
- Verificar que bot√≥n funciona (click test con Selenium)
- Verificar que link apunta a p√°gina correcta

**No automatizable** ‚ùå:
- ¬øEs el CTA persuasivo?
- ¬øEst√° bien ubicado?
- ¬øEl texto es claro?

**Tecnolog√≠a** (parcial):
```python
from selenium import webdriver

def check_ctas(url):
    driver = webdriver.Chrome()
    driver.get(url)

    cta_issues = []
    ctas = driver.find_elements_by_class_name('cta-button')

    for cta in ctas:
        try:
            cta.click()
            # Check if redirected to expected page
            if 'error' in driver.current_url or '404' in driver.title:
                cta_issues.append({
                    'text': cta.text,
                    'issue': 'Broken CTA link'
                })
            driver.back()
        except Exception as e:
            cta_issues.append({
                'text': cta.text,
                'issue': f'CTA not clickable: {e}'
            })

    driver.quit()
    return cta_issues
```

**Precisi√≥n**: ~85% (funcionalidad), 0% (efectividad)
**Esfuerzo**: 2 d√≠as implementaci√≥n
**Valor**: ‚≠ê‚≠ê‚≠ê (medio - solo verifica funcionamiento t√©cnico)

**Recomendaci√≥n**: Automatizar verificaci√≥n t√©cnica, evaluaci√≥n humana de efectividad.

---

#### 8. Dise√±o
**Qu√© requiere**: Verificar que p√°gina se ve bien, es responsive, no tiene errores visuales

**Automatizable** ‚úÖ (parcialmente):
- **Visual regression testing**: Screenshots antes/despu√©s, detectar cambios inesperados
- **Responsive testing**: Verificar que p√°gina se ve bien en m√≥vil/tablet/desktop

**No automatizable** ‚ùå:
- ¬øSe ve "bien"? (completamente subjetivo)
- ¬øEl dise√±o es atractivo? (requiere ojo humano)
- ¬øHay errores sutiles de alineaci√≥n? (dif√≠cil de detectar)

**Tecnolog√≠a** (visual regression):
```python
from playwright.sync_api import sync_playwright
import pixelmatch

def visual_regression_test(url, baseline_screenshot):
    with sync_playwright() as p:
        browser = p.chromium.launch()
        page = browser.new_page()

        # Take screenshots at different viewports
        viewports = [
            {'width': 1920, 'height': 1080},  # Desktop
            {'width': 768, 'height': 1024},   # Tablet
            {'width': 375, 'height': 667}     # Mobile
        ]

        issues = []
        for viewport in viewports:
            page.set_viewport_size(viewport)
            page.goto(url)
            screenshot = page.screenshot()

            # Compare with baseline
            diff = compare_images(baseline_screenshot, screenshot)
            if diff > 0.05:  # More than 5% difference
                issues.append({
                    'viewport': f"{viewport['width']}x{viewport['height']}",
                    'diff_percentage': diff * 100,
                    'issue': 'Visual changes detected'
                })

        browser.close()
        return issues
```

**Precisi√≥n**: ~75% (detecta cambios, no eval√∫a calidad)
**Esfuerzo**: 3-4 d√≠as implementaci√≥n + setup baseline
**Valor**: ‚≠ê‚≠ê‚≠ê (medio - √∫til para detectar regresiones, no para evaluar dise√±o inicial)

**Recomendaci√≥n**: √ötil en Stage 3 para detectar cambios no intencionados, pero no reemplaza evaluaci√≥n humana.

---

## üìä Resumen: ¬øQu√© Automatizar?

| Tarea | Automatizable | Precisi√≥n | Esfuerzo | Valor | Prioridad |
|-------|---------------|-----------|----------|-------|-----------|
| **Enlaces rotos** | ‚úÖ S√≠ | 95% | 1 d√≠a | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | **P0** (Alta) |
| **Im√°genes rotas** | ‚úÖ S√≠ | 90% | 1 d√≠a | ‚≠ê‚≠ê‚≠ê‚≠ê | **P0** (Alta) |
| **Enlaces incorrectos** | ‚úÖ Parcial | 80% | 2 d√≠as | ‚≠ê‚≠ê‚≠ê‚≠ê | **P1** (Media) |
| **CTAs (funcionalidad)** | ‚úÖ Parcial | 85% | 2 d√≠as | ‚≠ê‚≠ê‚≠ê | **P1** (Media) |
| **Erratas** | ‚ö†Ô∏è Parcial | 70% | 1 d√≠a | ‚≠ê‚≠ê‚≠ê | **P2** (Baja) |
| **Dise√±o (regresiones)** | ‚ö†Ô∏è Parcial | 75% | 4 d√≠as | ‚≠ê‚≠ê‚≠ê | **P2** (Baja) |
| **Informaci√≥n actualizada** | ‚ùå No | 50% | 3 d√≠as | ‚≠ê‚≠ê | **P3** (No hacer) |
| **FAQs relevancia** | ‚ùå No | N/A | 5 d√≠as | ‚≠ê | **P3** (No hacer) |
| **CTAs (efectividad)** | ‚ùå No | 0% | N/A | ‚≠ê | **P3** (No hacer) |
| **Dise√±o (est√©tica)** | ‚ùå No | 0% | N/A | ‚≠ê | **P3** (No hacer) |

**Conclusi√≥n**:
- ‚úÖ **~40% automatizable** (enlaces, im√°genes, CTAs t√©cnicos)
- ‚ö†Ô∏è **~20% parcialmente** (erratas, dise√±o regresiones)
- ‚ùå **~40% requiere humano** (informaci√≥n, FAQs, efectividad, est√©tica)

---

## üéØ Estrategia: Enfoque H√≠brido

### Stage 1: Task Manager Manual (Actual) ‚úÖ

**Objetivo**: Validar workflow y entender qu√© duele m√°s

**Features**:
- Humano hace todas las revisiones (100% manual)
- Task manager solo organiza, trackea, registra historial
- Sin automatizaci√≥n

**Duraci√≥n**: 1 mes uso real

**M√©tricas a recopilar**:
- ¬øQu√© encuentra M√ÅS frecuentemente? (enlaces rotos, erratas, info desactualizada?)
- ¬øQu√© tarea toma M√ÅS tiempo?
- ¬øQu√© secciones tienen M√ÅS problemas?

**Por qu√© empezar manual**:
1. Validar que task manager es √∫til antes de a√±adir complejidad
2. Recopilar datos reales para priorizar qu√© automatizar
3. Entender patrones (ej: siempre hay enlaces rotos en secci√≥n X)

---

### Stage 2: Task Manager + Escaneos Autom√°ticos (Futuro) üîÆ

**Objetivo**: Automatizar lo objetivo, humano valida y hace lo subjetivo

**Flujo propuesto**:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Scheduler (diario, 2am)                ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ  1. Check si toca activar tarea manual  ‚îÇ
‚îÇ  2. Ejecutar escaneo autom√°tico         ‚îÇ
‚îÇ     ‚îú‚îÄ Enlaces rotos                    ‚îÇ
‚îÇ     ‚îú‚îÄ Im√°genes rotas                   ‚îÇ
‚îÇ     ‚îú‚îÄ Enlaces incorrectos              ‚îÇ
‚îÇ     ‚îî‚îÄ Spell check                      ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ  3. Guardar resultados en BD            ‚îÇ
‚îÇ  4. Crear tarea con pre-report          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚îÇ
                    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Task Manager UI                        ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ  üìã Revisi√≥n: Renta Fija                ‚îÇ
‚îÇ  Activada: 01/11/2025                   ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ  ü§ñ ESCANEO AUTOM√ÅTICO (01/11 2:05am):  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ ‚ùå 3 enlaces rotos:              ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ   ‚Ä¢ /productos/bonos.html (404) ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ   ‚Ä¢ /fondos/detalle?id=123 (500)‚îÇ    ‚îÇ
‚îÇ  ‚îÇ   ‚Ä¢ external.com/page (timeout) ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ                                  ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ ‚úÖ 0 im√°genes rotas              ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ                                  ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ ‚ö†Ô∏è 2 posibles erratas:           ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ   ‚Ä¢ "interes" ‚Üí "inter√©s"       ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ   ‚Ä¢ "deposito" ‚Üí "dep√≥sito"     ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ                                  ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ [Ver detalles completos]        ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ  ‚úã REVISI√ìN MANUAL:                     ‚îÇ
‚îÇ  ‚òê Validar enlaces rotos (reportados)   ‚îÇ
‚îÇ  ‚òê Validar erratas sugeridas            ‚îÇ
‚îÇ  ‚òê Informaci√≥n actualizada              ‚îÇ
‚îÇ  ‚òê Preguntas frecuentes                 ‚îÇ
‚îÇ  ‚òê CTAs efectivos                       ‚îÇ
‚îÇ  ‚òê Dise√±o se ve bien                    ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ  Observaciones:                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îÇ
‚îÇ  ‚îÇ Se corrigieron los 3 enlaces    ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ rotos detectados. Solo 1 errata ‚îÇ    ‚îÇ
‚îÇ  ‚îÇ era real (inter√©s).             ‚îÇ    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ  [Marcar como Realizada]                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Benefits**:
- ü§ñ M√°quina encuentra problemas objetivos autom√°ticamente
- üë§ Humano valida resultados autom√°ticos + hace revisi√≥n subjetiva
- ‚è±Ô∏è Ahorra tiempo: ya sabe qu√© enlaces revisar (no tiene que buscarlos)
- üìä M√©tricas: tracking de falsos positivos, ajustar algoritmos

**Implementaci√≥n**:

**Backend** (nuevo):
```python
# scanner.py - Web scanner module

import requests
from bs4 import BeautifulSoup
from datetime import datetime
from database import db

def scan_section(section_id):
    """
    Escanea una secci√≥n del sitio y detecta problemas autom√°ticamente.
    """
    section = db.get_section(section_id)
    url = section['url']

    results = {
        'timestamp': datetime.now(),
        'section_id': section_id,
        'broken_links': check_broken_links(url),
        'broken_images': check_images(url),
        'spelling_errors': check_spelling(url),
        'suspicious_links': check_incorrect_links(url)
    }

    # Save results to DB
    db.save_scan_results(results)

    return results

# scheduler.py - Updated to include scanning

from apscheduler.schedulers.blocking import BlockingScheduler
from scanner import scan_section

def activate_tasks():
    """
    Revisa qu√© secciones toca activar y ejecuta escaneo autom√°tico.
    """
    sections_to_activate = get_sections_due_today()

    for section in sections_to_activate:
        # Run automated scan
        scan_results = scan_section(section['id'])

        # Create task with scan results pre-loaded
        task_id = create_task(section['id'])
        link_scan_to_task(task_id, scan_results)

        print(f"‚úì Activated task for {section['name']} with automated scan")

scheduler = BlockingScheduler()
scheduler.add_job(activate_tasks, 'cron', hour=2)  # 2am daily
scheduler.start()
```

**Frontend** (actualizado):
```javascript
// Mostrar resultados de escaneo autom√°tico en UI

function renderTask(task) {
    const taskCard = document.createElement('div');
    taskCard.className = 'task-card';

    // Automated scan section
    if (task.scan_results) {
        const scanSection = `
            <div class="automated-scan">
                <h3>ü§ñ Escaneo Autom√°tico</h3>
                <p class="scan-time">Ejecutado: ${task.scan_results.timestamp}</p>

                ${renderBrokenLinks(task.scan_results.broken_links)}
                ${renderBrokenImages(task.scan_results.broken_images)}
                ${renderSpellingErrors(task.scan_results.spelling_errors)}

                <button onclick="viewFullReport(${task.id})">
                    Ver detalles completos
                </button>
            </div>
        `;
        taskCard.innerHTML += scanSection;
    }

    // Manual checklist section
    const manualSection = `
        <div class="manual-review">
            <h3>‚úã Revisi√≥n Manual</h3>
            ${renderChecklist(task.checklist)}
            ${renderObservations(task.observations)}
        </div>
    `;
    taskCard.innerHTML += manualSection;

    return taskCard;
}
```

**Esfuerzo**: 3-5 d√≠as implementaci√≥n
- D√≠a 1: Web scanner b√°sico (enlaces + im√°genes)
- D√≠a 2: Integraci√≥n con scheduler y BD
- D√≠a 3: UI para mostrar resultados autom√°ticos
- D√≠a 4-5: Spell check + refinar UX

---

### Stage 3: Automatizaci√≥n Avanzada (Futuro Lejano) üöÄ

**Objetivo**: M√°xima automatizaci√≥n, humano solo interviene cuando hay problemas

**Features avanzadas**:

**1. Escaneo continuo**
- Scanner corre cada noche (no solo cuando toca revisi√≥n manual)
- Detecta problemas en tiempo real
- Crea tareas solo si encuentra issues (no preventivas)

**2. Visual regression testing**
- Screenshots autom√°ticos cada semana
- Detecta cambios visuales no intencionados
- Alerta si dise√±o se rompe

**3. SEO & Performance**
- Lighthouse scores autom√°ticos
- Detectar p√°ginas lentas
- Verificar meta tags, structured data

**4. Integraci√≥n con analytics**
- Detectar p√°ginas con alta tasa de rebote
- Priorizar revisi√≥n de p√°ginas m√°s visitadas
- Correlacionar problemas t√©cnicos con m√©tricas de negocio

**5. Dashboard de m√©tricas**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  AgendaRenta4 - Dashboard                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                   ‚îÇ
‚îÇ  üìä √öltimo Mes                                    ‚îÇ
‚îÇ  ‚îú‚îÄ 12 tareas completadas                        ‚îÇ
‚îÇ  ‚îú‚îÄ 47 enlaces rotos detectados ‚Üí 45 corregidos  ‚îÇ
‚îÇ  ‚îú‚îÄ 23 erratas sugeridas ‚Üí 8 aplicadas           ‚îÇ
‚îÇ  ‚îî‚îÄ 3 im√°genes rotas detectadas ‚Üí 3 corregidas   ‚îÇ
‚îÇ                                                   ‚îÇ
‚îÇ  üéØ Efectividad del Scanner                       ‚îÇ
‚îÇ  ‚îú‚îÄ Enlaces rotos: 96% precisi√≥n (2% falsos pos.)‚îÇ
‚îÇ  ‚îú‚îÄ Erratas: 35% precisi√≥n (muchos falsos pos.)  ‚îÇ
‚îÇ  ‚îî‚îÄ Im√°genes: 100% precisi√≥n                     ‚îÇ
‚îÇ                                                   ‚îÇ
‚îÇ  üî• Secciones con M√°s Problemas                   ‚îÇ
‚îÇ  1. Renta Fija (12 issues/mes)                   ‚îÇ
‚îÇ  2. Fondos (8 issues/mes)                        ‚îÇ
‚îÇ  3. Dep√≥sitos (5 issues/mes)                     ‚îÇ
‚îÇ                                                   ‚îÇ
‚îÇ  ‚è∞ Pr√≥ximas Revisiones                           ‚îÇ
‚îÇ  ‚Ä¢ Renta Fija - ma√±ana                           ‚îÇ
‚îÇ  ‚Ä¢ Fondos - en 3 d√≠as                            ‚îÇ
‚îÇ  ‚Ä¢ Seguros - en 1 semana                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Esfuerzo**: 1-2 semanas implementaci√≥n
**ROI**: Solo si el sistema se usa por >6 meses

---

## üõ†Ô∏è Stack Tecnol√≥gico (Stage 2)

### Web Scraping & Testing
- **requests** - HTTP requests para check links/images
- **Beautiful Soup** - Parse HTML y extract links/text
- **Selenium** o **Playwright** - Testing interactivo (CTAs, JavaScript)
- **LanguageTool** - Spell checking espa√±ol
- **pixelmatch** - Visual regression testing

### Scheduler
- **APScheduler** - Escaneos programados
- **Celery** (opcional) - Si necesitamos queue/workers para escaneos pesados

### Storage
- Nueva tabla en SQLite:
```sql
CREATE TABLE scan_results (
    id INTEGER PRIMARY KEY,
    section_id INTEGER,
    timestamp DATETIME,
    broken_links JSON,
    broken_images JSON,
    spelling_errors JSON,
    other_issues JSON,
    FOREIGN KEY (section_id) REFERENCES sections(id)
);

CREATE TABLE task_scans (
    task_id INTEGER,
    scan_result_id INTEGER,
    FOREIGN KEY (task_id) REFERENCES tasks(id),
    FOREIGN KEY (scan_result_id) REFERENCES scan_results(id)
);
```

---

## üìã Plan de Implementaci√≥n (Stage 2)

### Fase 1: Validaci√≥n de Utilidad (1 mes)
**ANTES de implementar automatizaci√≥n:**

1. Usar Stage 1 (task manager manual) por 1 mes
2. Recopilar m√©tricas:
   - ¬øQu√© problemas encuentra m√°s frecuentemente?
   - ¬øCu√°nto tiempo toma cada tipo de revisi√≥n?
   - ¬øQu√© duele m√°s?
3. Decidir si vale la pena automatizar

**Criterios para continuar a Stage 2**:
- ‚úÖ Task manager es √∫til (se usa regularmente)
- ‚úÖ >50% del tiempo se va en encontrar enlaces rotos/im√°genes rotas
- ‚úÖ Esposa dice "ojal√° esto se detectara autom√°ticamente"

---

### Fase 2: Implementaci√≥n de Scanner B√°sico (Semana 1)

**D√≠a 1-2: Enlaces rotos + Im√°genes**
```bash
# Estructura de archivos
agendaRenta4/
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ app.py (Flask app existente)
‚îÇ   ‚îú‚îÄ‚îÄ scanner/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ link_checker.py    # Check broken links
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ image_checker.py   # Check broken images
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils.py
‚îÇ   ‚îî‚îÄ‚îÄ scheduler.py (actualizado)
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îî‚îÄ‚îÄ test_scanner.py
‚îî‚îÄ‚îÄ requirements.txt (actualizado)
```

**Implementaci√≥n**:
1. M√≥dulo `link_checker.py` - detectar enlaces rotos
2. M√≥dulo `image_checker.py` - detectar im√°genes rotas
3. Unit tests b√°sicos
4. Integrar con scheduler existente

**Output**: Scanner funcional que detecta enlaces/im√°genes rotas

---

**D√≠a 3: Integraci√≥n con BD y Task Manager**
1. Tabla `scan_results` en BD
2. API endpoint: `GET /api/tasks/:id/scan-results`
3. Modificar task creation para incluir scan results
4. Testing end-to-end

**Output**: Scan results guardados y accesibles desde tasks

---

**D√≠a 4-5: UI para Mostrar Resultados**
1. Componente de "Escaneo Autom√°tico" en task card
2. Lista de enlaces rotos con links clickables
3. Bot√≥n "Ver detalles completos" ‚Üí modal con full report
4. Visual feedback (‚úÖ/‚ùå/‚ö†Ô∏è)

**Output**: Usuario ve resultados de escaneo en UI

---

### Fase 3: Validaci√≥n de Precisi√≥n (Semana 2)

**Objetivo**: Medir falsos positivos y ajustar algoritmos

1. Usar scanner por 1 semana
2. Tu esposa valida cada resultado:
   - ¬øEs realmente un link roto? (true positive)
   - ¬øFalsa alarma? (false positive)
3. Calcular precision: `TP / (TP + FP)`
4. Ajustar thresholds y reglas

**Target**: >90% precisi√≥n para enlaces, >85% para im√°genes

---

### Fase 4: Expansi√≥n (Semanas 3-4)

**Si Fase 3 es exitosa, a√±adir**:
- Spell checker (Day 1-2)
- Enlaces incorrectos (Day 3-4)
- CTAs funcionales con Selenium (Day 5-7)

**Si no, iterar**:
- Refinar algoritmos existentes
- Reducir falsos positivos
- Mejorar UX de resultados

---

## üö´ Limitaciones y Consideraciones

### 1. Acceso al Sitio del Banco
**Problema**: Sitio puede requerir autenticaci√≥n, VPN, o estar detr√°s de firewall.

**Soluci√≥n**:
- Si p√∫blico ‚Üí scraping directo OK
- Si requiere login ‚Üí guardar credenciales (Stage 3, con encryption)
- Si VPN ‚Üí correr scanner desde m√°quina con acceso

### 2. Rate Limiting y Politeness
**Problema**: No queremos hacer DoS accidental al sitio del banco.

**Soluci√≥n**:
```python
import time

def check_links_politely(links):
    results = []
    for link in links:
        response = requests.get(link)
        results.append(response)
        time.sleep(1)  # 1 segundo entre requests
    return results
```

**Best practices**:
- `User-Agent` identificable (no fingir ser browser normal)
- Respetar `robots.txt`
- Rate limit: max 1 request/segundo
- Correr en off-hours (2-4am)

### 3. Pol√≠ticas de Seguridad del Banco
**Problema**: Puede que el banco no permita scraping automatizado.

**Soluci√≥n**:
- **Opci√≥n A**: Pedir permiso interno (mejor)
- **Opci√≥n B**: Scraping "gentil" que no impacta performance
- **Opci√≥n C**: Solo automatizar en entorno de staging (no producci√≥n)

‚ö†Ô∏è **Importante**: Validar con IT del banco antes de implementar.

### 4. Mantenimiento de Selectores CSS
**Problema**: Si sitio cambia estructura HTML, scanner se rompe.

**Soluci√≥n**:
- Usar selectores gen√©ricos (`a[href]`, `img[src]`)
- Evitar selectores muy espec√≠ficos (`.btn-primary-v2-deprecated`)
- Test suite para detectar cuando scanner falla

### 5. Falsos Positivos
**Problema**: Scanner reporta problemas que no son reales.

**Soluci√≥n**:
- Whitelist de links conocidos (CDNs, partners)
- Configuraci√≥n de timeouts apropiados
- Humano siempre valida antes de actuar
- Tracking de precision para ajustar algoritmos

---

## üí° Recomendaci√≥n Final

### Immediate (Stage 1 - Ahora)
‚úÖ **Task manager manual** - Validar workflow primero
- Sin automatizaci√≥n
- Recopilar m√©tricas de uso real

### Near Future (Stage 2 - 1-2 meses)
‚è≥ **Scanner b√°sico** - Solo si Stage 1 es exitoso
- Enlaces rotos + im√°genes (prioridad alta)
- Humano valida resultados
- Medir precisi√≥n y ajustar

### Far Future (Stage 3 - 6+ meses)
üîÆ **Automatizaci√≥n avanzada** - Solo si Stage 2 demuestra ROI
- Visual regression
- SEO monitoring
- Dashboard de m√©tricas
- Escaneo continuo

---

## üéØ Criterios de Decisi√≥n

**¬øCu√°ndo implementar Stage 2?**

Implementar automatizaci√≥n SI:
- ‚úÖ Task manager se usa activamente por >1 mes
- ‚úÖ >50% del tiempo se va en encontrar enlaces rotos
- ‚úÖ Esposa encuentra >5 enlaces rotos por revisi√≥n
- ‚úÖ Hay tiempo/recursos para mantener scanner

NO implementar SI:
- ‚ùå Task manager no se usa regularmente
- ‚ùå Problemas principales son subjetivos (info desactualizada)
- ‚ùå Pocas issues t√©cnicas encontradas (<2 por revisi√≥n)
- ‚ùå No hay tiempo para mantenimiento

**Regla de oro**: Automatizar dolor real, no dolor imaginado.

---

## üìö Recursos T√©cnicos

### Librer√≠as Recomendadas
```txt
# requirements.txt (Stage 2 additions)

# Web scraping
requests==2.31.0
beautifulsoup4==4.12.2
lxml==4.9.3

# Spell checking
language-tool-python==2.7.1

# Browser automation (opcional)
playwright==1.40.0
selenium==4.15.2

# Scheduling
APScheduler==3.10.4

# Testing
pytest==7.4.3
responses==0.24.1  # Mock HTTP requests
```

### Ejemplos de C√≥digo Completos
Ver carpeta `docs/future/code-examples/` (crear en Stage 2):
- `link_checker_example.py`
- `image_checker_example.py`
- `spell_checker_example.py`
- `visual_regression_example.py`

### Herramientas Alternativas (SaaS)
Si no quieres desarrollar custom:
- **Broken Link Checker** (gratis, online)
- **Dead Link Checker** (gratis, online)
- **Screaming Frog SEO Spider** (app desktop, free tier)
- **Percy** (visual regression, $$ pero potente)
- **Checkly** (monitoring + testing, $$)

---

## üìù Notas Finales

**Filosof√≠a**:
> "Automatizar lo medible, humano para lo invaluable."

**Recordatorios**:
1. Automatizaci√≥n NO reemplaza juicio humano
2. Precisi√≥n < 100% ‚Üí siempre validar
3. Implementar solo si dolor es real (medido)
4. Mantener simplicidad ‚Üí complejidad solo si ROI claro

**Pr√≥ximo paso**:
- Usar Stage 1 por 1 mes
- Revisar este documento despu√©s
- Decidir si Stage 2 aporta valor

---

**Documento creado**: 2025-10-28
**Autor**: An√°lisis conjunto (Jes√∫s + Claude)
**Estado**: Planificaci√≥n futura (no implementar todav√≠a)
**Revisi√≥n**: Despu√©s de 1 mes uso de Stage 1